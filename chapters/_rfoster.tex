\section{Frontend - Webapplikation als REST-Client}
\subsection{Einleitung}
Das \Gls{backend} muss mit dem \Gls{frontend} verbunden werden.Es gibt unterschiedliche Möglichkeiten dies zu realisieren. Beim Realisieren, muss darauf geachtet werden, dass eine Struktur vorhanden ist. Es werden 2 verschiedene \Gls{designpattern} angeschaut und verglichen. Umgesetzt wird dann ein \Gls{designpattern} mithilfe von \Gls{js}. Hier kann ein \Gls{jsframework} zum Einsatz kommen. Dazu werden hier verschiedene \Gls{jsframework}s angeschaut und verglichen. Für die Verarbeitung der Daten ist es wichtig Datenformate festzulegen. Die Aufbereitung der Elemente fürs \Gls{frontend} mit den Daten des \Gls{backend}s wird ebenfalls angeschaut.
\newline
\newline
Daraus erschließt sich eine gewisse Fragestellung, die in den nächsten Seiten beantwortet wird. Zum Ersten, welche Unterschiede es zwischen den \Gls{designpattern}n \Gls{mvvm} und \Gls{mvc} gibt bei der Datenpräsentation und -manipulation. Des weiteren ist auch interessant, mit welchen Werkzeugen bzw. \Gls{jsframework}s die jeweiligen Methoden Zugriffs-performant umgesetzt werden können.
\subsection{Entwurfsmuster}
Dieser Teil des Projektes wird in Verwendung eines \Gls{designpattern}s umgesetzt. Zwei \Gls{mv*} \Gls{designpattern}s werden hierbei in Betrachtung gezogen. Zum einen \Gls{mvvm} und zum anderen \Gls{mvc}. Es kommen diese zwei Entwurfsmuster in Frage, da \Gls{mvc} in sehr bekanntes \Gls{designpattern} ist und \Gls{mvvm} eine neuere Variante von \Gls{mvc} ist.
\subsubsection{MVC}
\Gls{mvc} ist ein \Gls{designpattern} mit dem eine Software in die drei Teile (Model, View und Controller) geteilt wird\cite{mvc}.\\
Das Model beinhaltet alle Daten der Software und auch alle Funktionen, die mit den Daten interagieren oder mit ihnen rechnen.\\
Die View ist der Teil der Software, die Benutzer*innen sehen und mit denen sie interagieren. Dieser Teil der Software beinhaltet keine wichtigen Daten oder Funktionen, welche Daten bearbeiten. Sie hört nur auf Benutzereingaben und zeigt die bereitgestellten Daten an.\\
Der Controller ist der Teil der Software, der Model und View verbindet. In dem Controller wird auf die Benutzereingaben reagiert und die richtigen Funktionen aus dem Model aufgerufen.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/mvc}
	\caption[Übersicht des MVC-Patterns]{Übersicht über die Komponenten des MVC-Patterns und ihre Zusammenhänge}
	\label{fig:mvc}
\end{figure}
\subsubsection{MVVM}
\Gls{mvvm} oder auch \Gls{mvvc} ist ein \Gls{designpattern} mit dem eine Software in drei Teile geteilt wird.\cite{mvvm_vue} Jedoch wird bei \Gls{mvvm} die Software in Model, View und ViewModel aufgeteilt.\\
Das Model beinhaltet wie im konventionellen \Gls{mvc}-Pattern alle wichtigen Daten und Funktionen.\\
Die View ist wie beim \Gls{mvc}-Pattern der Teil der Software, mit der Benutzer*innen interagieren.\\
Das ViewModel ist ein Bindeglied zwischen Model und View. Dabei stellt es der View offen Funktionen zur Verfügung. Diese können auch Daten verändern bzw. mit Daten rechnen. Das Model kann über das ViewModel auch mit der View direkt interagieren.\\
\Gls{mvvm} sieht nicht vor, dass ein Controller verwendet wird. Diese Funktion übernimmt zu einem gewissen Teil das ViewModel bzw. auch die View und das Model.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/mvvm}
	\caption[Übersicht des MVVM-Patterns]{Übersicht über die Komponenten des MVVM-Patterns und ihre Zusammenhänge}
	\label{fig:mvvm}
\end{figure}
\newpage
\subsubsection{Vergleich}
Diese zwei \Gls{designpattern} sind zwar sehr ähnlich, jedoch gibt es Unterschiede zwischen ihnen.\\\\
\Gls{mvc} ist ein Entwurfsmuster, welches auf einem niedrigen Level überall im Einsatz ist wie z.B.: bei Tastatureingaben\cite{mvc}. Dieses \Gls{designpattern} ist zwar schon lange Verfügbar, jedoch kann es bei Webapplikationen zu Problemen führen.\\
Bei der Entwicklung einer Webapplikation ist es nicht simpel, das Model von dem Controller zu trennen.\\
\Gls{mvvm} auf der anderen Seite, zielt explizit auf HTML5 ab\cite{mvvm_vue}. Somit ist es bei Webbasierten Applikationen zu bevorzugen.
\subsection{Umsetzungsmöglichkeiten}
Dieser Teil des Projekts wird mittels \Gls{js} umgesetzt. Hierbei kommen unterschiedliche \Gls{jsframework} in Frage. Hier werden die verbreitesten \Gls{jsframework}s vorgestellt und dann verglichen. \Gls{angular} wird nicht in Betrachtung gezogen, da dies ein \Gls{framework}  für professionelle Projekte ist und somit sehr umständlich ist\cite{angular_ex}.
\subsubsection{VueJS}
\gls{vue} ist ein progressives \Gls{jsframework}. Dies bedeutet, dass Vue in bereits bestehende Webseiten bzw. Webbasierte Software implementiert werden kann.\\
\Gls{vue} kann aber auch von Anfang an verwendet werden, wobei man hier mit den Bibliotheken von \Gls{vue} skalieren kann\cite{vuedoc}. \Gls{vue} kann Teile einer Webseite in Komponenten aufteilen, um diese öfters zu verwenden, falls dies notwendig ist. Jeder dieser Komponenten hat sein eigenes \Gls{html}, \Gls{css} und \Gls{js} File, was gebraucht wird, um diese Komponente zu rendern.\\
Um einzelnen Elementen \Gls{vue}-Funktionalität zu geben kann auf diese Elemente folgender Code angewendet werden\cite{vuedoc}:
\begin{code}{html}
	<!DOCTYPE html>
	<html lang="de">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<title>Kurzes VueJS-Beispiel</title>
		</head>
		<body>
			<h1>Überschrift</h1>
			<div id="app">
				<p> {{ text }} </p>
			</div>
			<script src="https://unpkg.com/vue"></script>
			<script>
				const app = new Vue({
					el: '#app',
					data: {
						text: 'Hier steht Text!'
					}
				})
			</script>
		</body>
	</html>
\end{code}
\subsubsection{React}
\Gls{react} ist eine \Gls{js}-Bibliothek, mit der man Benutzeroberflächen entwickeln kann\cite{reactdoc}. \Gls{react} hat wie \Gls{vue} Komponenten. Dies bedeutet, dass man einzelne Elemente öfters verwenden kann, falls man dies benötigt.\\
\Gls{react} ist von Facebook entwickelt worden und wurde 2013 als \Gls{opensource}-Lösung veröffentlicht.\\
Folgender Code beschreibt eine Beispiel-React Webseite\cite{reactdoc}:
\begin{code}{html}
	<!DOCTYPE html>
	<html lang="de">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<title>Kurzes React-Beispiel</title>
		</head>
		<body>
			<h1>Überschrift</h1>
			<div id="likebuttoncontainer"></div>
			
			<!-- Load React. -->
			<!-- Note: when deploying, replace "development.js" with "production.min.js". -->
			<script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
			<!-- Load our React component. -->
			<script src="likebutton.js"></script>
		</body>
	</html>
\end{code}
In der letzten Zeile des body-tags, wird auf ein "likebutton.js" referenziert. Dies ist eine Komponente und muss noch erstellt werden\cite{reactdoc}:
\begin{code}{js}
	'use strict';
	
	const e = React.createElement;
	
	class LikeButton extends React.Component {
		constructor(props) {
			super(props);
			this.state = { liked: false };
		}
		
		render() {
			if (this.state.liked) {
				return 'You liked this.';
			}
			
			return e(
			'button',
			{ onClick: () => this.setState({ liked: true }) },
			'Like'
			);
		}
	}
	
	const domContainer = document.querySelector('#likebuttoncontainer');
	ReactDOM.render(e(LikeButton), domContainer);
\end{code}
\subsubsection{Ohne Framework}
Die Schnittstelle zwischen \Gls{backend} und \Gls{frontend} kann auch ohne ein \Gls{framework} umgesetzt werden. Dies ist bei kleinen und leichten Applikationen von Vorteil, da keine umständlichen \Gls{jsframework}s aufgesetzt und richtig implementiert werden müssen. Ohne \Gls{framework} implementiert man einfach eine \Gls{js}-Datei in eine Webseite um die gewünschte Funktionalität zu haben. Mit folgendem Code kann eine Implementierung einer \Gls{js}-Datei umgesetzt werden:
\begin{code}{html}
	<!DOCTYPE html>
	<html lang="de">
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<title>Kurzes Plain-Beispiel</title>
		</head>
		<body>
			<div id="inhalt">
				<h1>Überschrift</h1>
			</div>
			<!-- Die Implementierung der JavaScript-Datei -->
			<script src="javascript.js"></script>
		</body>
	</html>
\end{code}
Es kann auch direkt in ein \Gls{html}-File \Gls{js} in ein <script></script> geschrieben werden.
\subsubsection{Vergleich}
Verglichen werden diese unterschiedlichen Umsetzungsmöglichkeiten an Design, Entwicklungszeit und Performanz.\\\\
Die Webseite, die für den Vergleich umgesetzt werden soll, wird mit den unterschiedlichen Umsetzungsmöglichkeiten umgesetzt.\\
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/example_page}
	\caption[Die Beispielwebseite]{Die Beispielwebseite, die mit den Umsetzungsmöglichkeiten umgesetzt werden soll.}
	\label{fig:example}
\end{figure}
Folgende Tabelle zeigt die unterschiedlichen Werte bei der Umsetzung der Beispielwebseite:
\begin{table}
	\centering
	\refstepcounter{table}
	\label{center}
	\begin{tabular}{lcccc}
		Kriterium        & \multicolumn{1}{l}{Maximale Punkte} & \multicolumn{1}{l}{VueJS} & \multicolumn{1}{l}{ReactJS} & \multicolumn{1}{l}{Ohne Framework}  \\
		Design           & \Gls{nan}                        &            \checkmark               &             \checkmark              &          \checkmark                           \\
		Entwicklungszeit & 10                         &             9              &               7            &               10                      \\
		Performanz       & 10                         &             8              &               5            &                 10                    \\
		\Gls{loc}              & 10                         &             10              &               9            &                   3                  \\
		Gesamtpunkte     & 30                         &              26             &               21            &                23                    
	\end{tabular}
\end{table}
\paragraph{Kriterien:}
\subparagraph{Design:}
Das Design fällt in die Wertung, da hier geschaut wird, ob die Beispiel-Website so umgesetzt werden kann, oder ob die Umsetzung in diesem Design nicht möglich ist.
\subparagraph{Entwicklungszeit}
Die Entwicklungszeit zwischen den zwei \Gls{framework}s ist sehr ähnlich. Jedoch ist zu beachten, dass bei dem \Gls{vue} \Gls{framework} bereits mit Komponenten gearbeitet worden ist, und dadurch die Entwicklungszeit höher ist als notwendig. Ohne \Gls{framework} hatte die kürzeste Entwicklungszeit, da nichts installiert, importiert oder aufgesetzt werden musste.
\subparagraph{Performanz}
Ohne \Gls{framework} ist die Performanz sehr gut, da im Hintergrund keine \Gls{framework}s geladen werden müssen. Das \Gls{js} wird direkt ausgeführt. Bei \Gls{vue} und \Gls{react} wird viel im Hintergrund geladen und dadurch braucht es länger. Obwohl Komponenten verwendet worden sind, ist \Gls{vue} performanter als \Gls{react}.
\subparagraph{\Gls{loc}}
Die beiden \Gls{framework}s haben besonders gut abgeschnitten, da für die Umsetzung mit \Gls{vue} nur wenige Codezeilen geschrieben worden sind, da das meiste mit der Funktionalität von \Gls{vue} umsetzbar ist. \Gls{react} ist auch sehr gut, da auch sehr wenige Codezeilen geschrieben werden mussten. Jedoch wurde hier allgemein gesagt mehr selbst geschrieben, wodurch es nicht die vollen Punkte verdient. Ohne \Gls{framework} hat am wenigsten Punkte erhalten, da die Umsetzung nicht nur unübersichtlich und kompliziert im Vergleich ist, sonder auch, weil man damit rechnen muss, dass bei größeren Beispielen die Umsetzung noch komplizierter und unübersichtlicher wird.
\subsection{Aufbereitung der Daten}
Die Daten, welche von der REST-Schnittstelle gelesen werden, sind im \Gls{json} Format. Dies wird genauer im Kapitel \hyperref[sec:json]{Kommunikation und Datenformate} erklärt. Um die Daten von der REST-Schnittstelle zu bekommen wird \Gls{axios} verwendet. Mit dieser Bibliothek, kann eine \Gls{http}-Anfrage gesendet werden und damit die Daten von der REST-Schnittstelle ausgelesen werden. Im folgenden Code wird eine Beispiel-Anfrage gesendet:
\begin{code}{html}
	<!DOCTYPE html>
	<html>
		<head>
			<!-- Import von Axios -->
			<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
			<meta charset="UTF-8">
			<title>Axios-Anfrage</title>
		</head>
		<body>
			<script>
				// Anfrage an den Server um die Daten zu bekommen
				axios.get("http://localhost:3000/data").then(response => {
					//Die Daten, die zurückkommen werden in der Konsole ausgegeben
					console.log(response.data);
				})
			</script>
		</body>
	</html>
\end{code}
Die Daten welche von der Anfrage zurückkommen können dann verwendet werden, um \Gls{html}-Elemente zu erstellen oder zu verändern, um das \Gls{frontend} dynamisch mit den Daten zu füllen.\\Nachdem nicht alle Daten immer gebraucht werden, kann bei den Anfragen die Endung verändert werden, um spezifische Daten abzufragen. Dies muss natürlich von der REST-Schnittstelle unterstützt werden. Eine Beispiel Anfrage für solch eine spezifische Anfrage ist wie folgt:
\begin{code}{js}
	// Hier werden zb. die Daten von dem Benutzer 1234 abgefragt und zurückgegeben.
	axios.get("http://localhost:3000/user/1234/infos").then(response => {
		//Die Daten, die zurückkommen werden in der Konsole ausgegeben
		console.log(response.data);
	})
\end{code}

Die praktische Durchführung ist, wie bereits im vorherigen Kapitel besprochen, bei den Umsetzungsmöglichkeiten unterschiedlich.

\subsection{Fazit}
Nun ist es relativ simpel sich für eine Umsetzungsmöglichkeit zu entscheiden. Die vermutlich einfachste Variante für mich ist die Umsetzung des \Gls{mvvm}-\Gls{designpattern} mit dem \Gls{jsframework} \Gls{vue}. Dies kommt vor allem auf die Spezialisierung des \Gls{designpattern} an, da \Gls{mvvm} genau auf Web basierte Anwendungen zugeschnitten ist. \Gls{vue} auf der anderen Seite ist zu bevorzugen, da durch die Komponenten viel Zeit und somit auch Arbeit gespart werden kann und zum Zweiten, dass ich als Entwickler bereits Vorkenntnisse mit diesem \Gls{framework} habe und somit schneller als mit \Gls{react} zu dem gewünschten Ziel kommen werde.